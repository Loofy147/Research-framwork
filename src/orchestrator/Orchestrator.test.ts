/**
 * @file Unit tests for the MetaOrchestrator.
 */

import { describe, it, expect, vi } from 'vitest';
import { MetaOrchestrator } from './Orchestrator';
import { SimpleAdversarialVariant } from './variants/SimpleAdversarialVariant';
import { AgentVariantBase } from './variants/AgentVariant';
import type { AdversarialExperiment, Context, PerformanceMetrics } from './types';

// A mock target agent for testing purposes.
class MockTargetAgent extends AgentVariantBase {
  constructor(name: string) {
    super(name);
  }

  // This run method will be spied on to ensure it's called with the correct context.
  public async run(context: Context): Promise<PerformanceMetrics> {
    // In a real scenario, this agent would parse the context.taskDescription.
    // Here, we just return a metric based on the context's difficulty.
    const score = context.difficulty === 'high' ? 100 : 50;
    return Promise.resolve({ score, contextReceived: context });
  }
}

describe('MetaOrchestrator', () => {
  it('should run an adversarial benchmark experiment correctly', async () => {
    // 1. Setup
    const orchestrator = new MetaOrchestrator();

    const adversarialVariant = new SimpleAdversarialVariant();
    const targetVariant = new MockTargetAgent('TestTargetAgent');

    // Register variants with the orchestrator
    orchestrator.registerVariant(adversarialVariant);
    orchestrator.registerVariant(targetVariant);

    // Spy on the target agent's run method to verify it's called correctly
    const runSpy = vi.spyOn(targetVariant, 'run');
    const generateContextSpy = vi.spyOn(adversarialVariant, 'generateContext');

    // Define the experiment
    const experiment: AdversarialExperiment = {
      name: 'Test Adversarial Benchmark',
      adversarialVariant: 'SimpleAdversarialVariant',
      targetVariants: ['TestTargetAgent'],
      context: { initialTask: 'test' },
    };

    // 2. Execution
    const results = await orchestrator.runAdversarialBenchmark(experiment);

    // 3. Assertions
    // Check that the adversarial agent was called
    expect(generateContextSpy).toHaveBeenCalledOnce();
    expect(generateContextSpy).toHaveBeenCalledWith(experiment.context);

    // Check that the target agent was called
    expect(runSpy).toHaveBeenCalledOnce();

    // Check that the target agent received the context generated by the adversarial agent
    const generatedContext = await generateContextSpy.mock.results[0].value;
    expect(runSpy).toHaveBeenCalledWith(generatedContext);

    // Check the final results
    expect(results.size).toBe(1);
    expect(results.has('TestTargetAgent')).toBe(true);

    const targetResult = results.get('TestTargetAgent');
    expect(targetResult).toBeDefined();
    expect(targetResult?.score).toBe(100); // Because SimpleAdversarialVariant sets difficulty to 'high'
    expect(targetResult?.contextReceived.taskDescription).toContain('lorem ipsum');
  });

  it('should throw an error if a variant is not found', async () => {
    const orchestrator = new MetaOrchestrator();
    const experiment: AdversarialExperiment = {
      name: 'Test with Missing Variant',
      adversarialVariant: 'NonExistentVariant',
      targetVariants: [],
      context: {},
    };

    await expect(
      orchestrator.runAdversarialBenchmark(experiment)
    ).rejects.toThrow('Variant "NonExistentVariant" not found.');
  });

  it('should throw an error if the adversarial variant is not the correct type', async () => {
    const orchestrator = new MetaOrchestrator();
    const notAnAdversary = new MockTargetAgent('NotAnAdversary');
    orchestrator.registerVariant(notAnAdversary);

    const experiment: AdversarialExperiment = {
      name: 'Test with Invalid Adversary Type',
      adversarialVariant: 'NotAnAdversary',
      targetVariants: [],
      context: {},
    };

    await expect(
      orchestrator.runAdversarialBenchmark(experiment)
    ).rejects.toThrow(
      'Variant "NotAnAdversary" is not an adversarial variant.'
    );
  });
});